<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
*{margin:0;padding:0;box-sizing:border-box;}
body{
    font-family:'Apple SD Gothic Neo','Malgun Gothic','Noto Sans KR',sans-serif;
    background:linear-gradient(135deg,#FFF8F0 0%,#FFF0E6 50%,#F8F0FF 100%);
    display:flex;flex-direction:row;
    height:100vh;overflow:hidden;user-select:none;
    -webkit-user-select:none;
}

/* ============================================================
   Gallery Sidebar
   ============================================================ */
#gallery-panel{
    width:280px;min-width:280px;height:100vh;
    background:linear-gradient(180deg,#FFFCF5 0%,#FFF6EC 50%,#FBF2FF 100%);
    border-right:2px solid #FFE4C9;
    display:flex;flex-direction:column;overflow:hidden;
}
#gallery-header{
    padding:14px 16px 10px;text-align:center;
    border-bottom:1px solid #FFE4C9;
    background:rgba(255,255,255,0.6);
    flex-shrink:0;
}
#gallery-header h2{font-size:1.15em;color:#FF6B6B;margin-bottom:2px;letter-spacing:-0.3px;}
#gallery-header p{font-size:0.75em;color:#bbb;}
#gallery-list{
    flex:1;overflow-y:auto;padding:10px;
    scrollbar-width:thin;scrollbar-color:#FFD700 transparent;
}
#gallery-list::-webkit-scrollbar{width:5px;}
#gallery-list::-webkit-scrollbar-track{background:transparent;}
#gallery-list::-webkit-scrollbar-thumb{background:#FFD700;border-radius:3px;}

#gallery-empty{
    text-align:center;color:#ccc;font-size:0.85em;
    line-height:1.8;padding:40px 16px;
}

.gallery-item{
    background:white;border-radius:12px;padding:10px;
    margin-bottom:10px;box-shadow:0 2px 8px rgba(0,0,0,0.04);
    transition:transform 0.2s,box-shadow 0.2s;
    cursor:default;
}
.gallery-item:hover{
    transform:translateY(-2px);
    box-shadow:0 4px 14px rgba(0,0,0,0.08);
}
.gallery-item-header{
    display:flex;align-items:center;gap:6px;margin-bottom:8px;
}
.rank-badge{
    width:22px;height:22px;border-radius:50%;
    display:flex;align-items:center;justify-content:center;
    font-size:0.7em;font-weight:bold;color:white;flex-shrink:0;
}
.rank-1{background:linear-gradient(135deg,#FFD700,#FFA000);}
.rank-2{background:linear-gradient(135deg,#C0C0C0,#9E9E9E);}
.rank-3{background:linear-gradient(135deg,#CD7F32,#A0522D);}
.rank-n{background:#ddd;color:#888;}
.gallery-item-title{
    flex:1;font-size:0.8em;color:#555;font-weight:500;
    overflow:hidden;text-overflow:ellipsis;white-space:nowrap;
}
.gallery-thumb{
    width:100%;border-radius:8px;
    aspect-ratio:920/540;object-fit:cover;
    background:#FFFDF7;border:1px solid #f0ebe0;
}
.gallery-item-footer{
    display:flex;align-items:center;justify-content:space-between;
    margin-top:8px;
}
.gallery-time{font-size:0.68em;color:#ccc;}
.like-btn{
    display:flex;align-items:center;gap:4px;
    background:none;border:1.5px solid #FFE0E0;border-radius:16px;
    padding:3px 10px;cursor:pointer;font-size:0.8em;color:#FF6B6B;
    transition:all 0.2s;outline:none;
}
.like-btn:hover{background:#FFF0F0;border-color:#FF6B6B;}
.like-btn.liked{background:#FF6B6B;color:white;border-color:#FF6B6B;}
.like-btn .like-icon{font-size:1em;transition:transform 0.3s;}
.like-btn:active .like-icon{transform:scale(1.3);}

/* ============================================================
   Main Content
   ============================================================ */
#main-content{
    flex:1;display:flex;flex-direction:column;align-items:center;
    overflow:hidden;min-width:0;
}
header{text-align:center;padding:12px 0 6px;}
header h1{font-size:1.6em;color:#FF6B6B;margin-bottom:2px;letter-spacing:-0.5px;}
header p{font-size:0.85em;color:#aaa;font-style:italic;}

#canvas-wrap{
    position:relative;margin:8px auto;border-radius:14px;overflow:hidden;
    box-shadow:0 4px 25px rgba(0,0,0,0.08);border:2px solid #FFE4C9;
    width:min(780px,calc(100% - 30px));
    background:#FFFDF7;
}
canvas{display:block;cursor:crosshair;width:100%;height:auto;}
#hint{
    position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
    text-align:center;color:#ccc;font-size:1.05em;line-height:2;
    pointer-events:none;transition:opacity 0.6s ease;
}
#hint span{font-size:0.8em;color:#ddd;}

#toolbar{
    display:flex;align-items:center;gap:7px;padding:10px 18px;
    background:rgba(255,255,255,0.95);border-radius:28px;
    box-shadow:0 2px 18px rgba(0,0,0,0.06);margin-top:10px;
    flex-wrap:wrap;justify-content:center;
    backdrop-filter:blur(8px);
}
.tool-sep{width:1px;height:28px;background:#eee;margin:0 4px;}

.color-btn{
    width:30px;height:30px;border-radius:50%;border:3px solid transparent;
    cursor:pointer;transition:all 0.2s;outline:none;flex-shrink:0;
}
.color-btn:hover{transform:scale(1.18);}
.color-btn.active{border-color:#555;box-shadow:0 0 0 2px white,0 0 0 4px #555;}

.tool-btn{
    padding:5px 12px;border:none;border-radius:18px;background:#f5f5f5;
    cursor:pointer;font-size:1.05em;transition:all 0.2s;white-space:nowrap;
}
.tool-btn:hover{background:#ebebeb;transform:scale(1.06);}
.tool-btn:active{transform:scale(0.97);}

#analyze-btn{
    background:linear-gradient(135deg,#FF6B6B,#FF8E53);color:white;
    font-weight:bold;padding:8px 22px;font-size:0.95em;
    box-shadow:0 2px 10px rgba(255,107,107,0.3);
}
#analyze-btn:hover{background:linear-gradient(135deg,#FF5252,#FF7043);box-shadow:0 3px 15px rgba(255,107,107,0.4);}
#analyze-btn.gpt-mode{
    background:linear-gradient(135deg,#10B981,#059669);
    box-shadow:0 2px 10px rgba(16,185,129,0.3);
}
#analyze-btn.gpt-mode:hover{background:linear-gradient(135deg,#059669,#047857);box-shadow:0 3px 15px rgba(16,185,129,0.4);}

#size-slider{width:70px;accent-color:#FF6B6B;vertical-align:middle;cursor:pointer;}
.size-label{font-size:0.7em;color:#bbb;}

/* Modal */
#modal{display:none;position:fixed;top:0;left:0;width:100%;height:100%;z-index:100;}
#modal.show{display:flex;align-items:center;justify-content:center;}
#modal-bg{position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.45);backdrop-filter:blur(5px);}
#modal-card{
    position:relative;
    background:linear-gradient(145deg,#FFFCF2,#FFF6E6);
    border:2px solid #FFD700;border-radius:22px;padding:28px 32px;
    max-width:640px;width:90%;max-height:82vh;overflow-y:auto;
    box-shadow:0 12px 50px rgba(255,215,0,0.25);
    animation:slideUp 0.5s cubic-bezier(0.16,1,0.3,1);
    line-height:1.85;
}
@keyframes slideUp{from{transform:translateY(60px);opacity:0;}to{transform:translateY(0);opacity:1;}}

#modal-card h2{text-align:center;color:#B8860B;margin-bottom:12px;font-size:1.35em;}
#modal-card .label{color:#D4456B;font-weight:bold;}
#modal-card .title-work{font-size:1.35em;text-align:center;color:#8B4513;margin:10px 0;font-style:italic;}
#modal-card .stars{text-align:center;font-size:1.5em;letter-spacing:3px;margin:6px 0;}
#modal-card .interpretation{
    background:rgba(255,255,255,0.6);padding:16px;border-radius:12px;
    margin:14px 0;border-left:4px solid #FFD700;
}
#modal-card .interpretation p{margin-bottom:8px;}
#modal-card .interpretation p:last-child{margin-bottom:0;}
#modal-card .emotion{background:rgba(255,200,200,0.15);padding:12px 16px;border-radius:12px;margin:12px 0;}
#modal-card .closing{text-align:center;font-style:italic;color:#999;margin-top:16px;padding-top:12px;border-top:1px dashed #ddd;font-size:0.95em;}
#modal-card .info-line{margin:6px 0;font-size:0.95em;}
#modal-card .gpt-tag{display:inline-block;font-size:0.7em;background:#10B981;color:white;padding:2px 8px;border-radius:8px;vertical-align:middle;}

.modal-btns{display:flex;gap:8px;justify-content:center;margin-top:18px;flex-wrap:wrap;}
#save-btn{
    padding:10px 22px;border:none;border-radius:22px;
    background:linear-gradient(135deg,#10B981,#059669);
    color:white;font-size:0.9em;cursor:pointer;font-weight:bold;transition:all 0.2s;
}
#save-btn:hover{transform:scale(1.05);box-shadow:0 3px 12px rgba(16,185,129,0.3);}

#share-btn{
    padding:10px 22px;border:none;border-radius:22px;
    background:linear-gradient(135deg,#F59E0B,#D97706);
    color:white;font-size:0.9em;cursor:pointer;font-weight:bold;transition:all 0.2s;
}
#share-btn:hover{transform:scale(1.05);box-shadow:0 3px 12px rgba(245,158,11,0.3);}
#share-btn:disabled{opacity:0.5;cursor:not-allowed;transform:none;}

#email-btn{
    padding:10px 22px;border:none;border-radius:22px;
    background:linear-gradient(135deg,#3B82F6,#2563EB);
    color:white;font-size:0.9em;cursor:pointer;font-weight:bold;transition:all 0.2s;
}
#email-btn:hover{transform:scale(1.05);box-shadow:0 3px 12px rgba(59,130,246,0.3);}

#email-modal{display:none;position:fixed;top:0;left:0;width:100%;height:100%;z-index:101;}
#email-modal.show{display:flex;align-items:center;justify-content:center;}
#email-modal-bg{position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.35);backdrop-filter:blur(3px);}
#email-card{
    position:relative;background:white;border-radius:18px;padding:24px 28px;
    max-width:420px;width:90%;box-shadow:0 8px 30px rgba(0,0,0,0.12);
    animation:slideUp 0.4s cubic-bezier(0.16,1,0.3,1);
}
#email-card h3{font-size:1.15em;margin-bottom:12px;color:#333;}
#email-input{
    width:100%;padding:10px 14px;border:2px solid #eee;border-radius:10px;
    font-size:0.9em;outline:none;transition:border-color 0.2s;
}
#email-input:focus{border-color:#3B82F6;}
#email-status{font-size:0.85em;margin-top:10px;padding:8px 12px;border-radius:8px;text-align:center;display:none;}
#email-status.success{display:block;background:#ECFDF5;color:#059669;}
#email-status.error{display:block;background:#FEF2F2;color:#DC2626;}
#email-status.sending{display:block;background:#EFF6FF;color:#2563EB;}
.email-btns{display:flex;gap:8px;margin-top:14px;}
.email-btns button{
    flex:1;padding:9px;border:none;border-radius:10px;font-size:0.95em;cursor:pointer;transition:all 0.2s;
}
#send-email-btn{background:linear-gradient(135deg,#3B82F6,#2563EB);color:white;font-weight:bold;}
#send-email-btn:hover{transform:scale(1.03);}
#send-email-btn:disabled{opacity:0.5;transform:none;cursor:not-allowed;}
#cancel-email-btn{background:#f0f0f0;color:#666;}
#cancel-email-btn:hover{background:#e5e5e5;}

#close-btn{
    padding:10px 22px;border:none;border-radius:22px;
    background:linear-gradient(135deg,#FF6B6B,#FF8E53);
    color:white;font-size:0.9em;cursor:pointer;font-weight:bold;transition:all 0.2s;
}
#close-btn:hover{transform:scale(1.05);box-shadow:0 3px 12px rgba(255,107,107,0.3);}

/* Doodle Detail Modal */
#detail-modal{display:none;position:fixed;top:0;left:0;width:100%;height:100%;z-index:102;}
#detail-modal.show{display:flex;align-items:center;justify-content:center;}
#detail-modal-bg{position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);backdrop-filter:blur(5px);}
#detail-card{
    position:relative;background:white;border-radius:18px;padding:24px;
    max-width:500px;width:90%;box-shadow:0 12px 40px rgba(0,0,0,0.15);
    animation:slideUp 0.4s cubic-bezier(0.16,1,0.3,1);
    text-align:center;
}
#detail-card img{
    width:100%;border-radius:12px;margin-bottom:14px;
    border:1px solid #f0ebe0;
}
#detail-card h3{color:#8B4513;font-size:1.1em;margin-bottom:10px;font-style:italic;}
#detail-card .detail-likes{font-size:1em;color:#FF6B6B;margin-bottom:14px;}
#detail-close-btn{
    padding:8px 24px;border:none;border-radius:18px;
    background:linear-gradient(135deg,#FF6B6B,#FF8E53);
    color:white;font-size:0.9em;cursor:pointer;font-weight:bold;
}

/* Share success toast */
#share-toast{
    position:fixed;top:20px;left:50%;transform:translateX(-50%) translateY(-80px);
    background:#10B981;color:white;padding:12px 24px;border-radius:12px;
    font-size:0.9em;font-weight:bold;box-shadow:0 4px 20px rgba(16,185,129,0.3);
    z-index:200;transition:transform 0.4s cubic-bezier(0.16,1,0.3,1);
    pointer-events:none;
}
#share-toast.show{transform:translateX(-50%) translateY(0);}

/* Loading */
#loading{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.4);z-index:99;align-items:center;justify-content:center;flex-direction:column;backdrop-filter:blur(3px);}
#loading.show{display:flex;}
#loading .spinner{font-size:3.5em;animation:spin 1.5s linear infinite;}
@keyframes spin{to{transform:rotate(360deg);}}
#loading p{color:white;font-size:1.1em;margin-top:12px;text-shadow:0 1px 4px rgba(0,0,0,0.3);}
#loading .dots::after{content:'';animation:dots 1.5s steps(4,end) infinite;}
@keyframes dots{0%{content:'';}25%{content:'.';}50%{content:'..';}75%{content:'...';}100%{content:'';}}

/* Scrollbar for modal */
#modal-card::-webkit-scrollbar{width:6px;}
#modal-card::-webkit-scrollbar-track{background:transparent;}
#modal-card::-webkit-scrollbar-thumb{background:#FFD700;border-radius:3px;}

/* Heartbeat animation */
@keyframes heartbeat{
    0%{transform:scale(1);}
    25%{transform:scale(1.3);}
    50%{transform:scale(1);}
    75%{transform:scale(1.15);}
    100%{transform:scale(1);}
}
.like-btn.just-liked .like-icon{animation:heartbeat 0.5s ease;}
</style>
</head>
<body>

<!-- Gallery Sidebar -->
<div id="gallery-panel">
    <div id="gallery-header">
        <h2>ğŸ† ë‚™ì„œ ë­í‚¹</h2>
        <p>ì¶”ì²œìˆœ Â· ì´ <span id="gallery-count">0</span>ê°œ</p>
    </div>
    <div id="gallery-list">
        <div id="gallery-empty">
            ì•„ì§ ê³µìœ ëœ ë‚™ì„œê°€ ì—†ì–´ìš”!<br><br>
            ë‚™ì„œë¥¼ ê·¸ë¦¬ê³  AI ë¶„ì„ í›„<br>
            ê°¤ëŸ¬ë¦¬ì— ê³µìœ í•´ë³´ì„¸ìš” ğŸ¨
        </div>
    </div>
</div>

<!-- Main Content -->
<div id="main-content">
    <header>
        <h1>ğŸ¨ ë‚™ì„œ ë¶„ì„ê°€</h1>
        <p>- ëª¨ë“  ë‚™ì„œëŠ” ë¬´ì˜ì‹ì„ íˆ¬ì˜í•œë‹¤ -</p>
    </header>

    <div id="canvas-wrap">
        <canvas id="canvas" width="780" height="460"></canvas>
        <div id="hint">
            í´ë¦­í•˜ê³  ë“œë˜ê·¸í•´ì„œ<br>ììœ ë¡­ê²Œ ê·¸ë ¤ë³´ì„¸ìš”!<br><br>
            <span>ìƒê°í•˜ì§€ ë§ê³ , ê·¸ëƒ¥ ê·¸ë¦¬ì„¸ìš”! ğŸ¨</span>
        </div>
    </div>

    <div id="toolbar">
        <button class="color-btn active" style="background:#E63946" onclick="setColor('#E63946',this)" title="ë¹¨ê°•"></button>
        <button class="color-btn" style="background:#F4845F" onclick="setColor('#F4845F',this)" title="ì½”ë„"></button>
        <button class="color-btn" style="background:#F7B801" onclick="setColor('#F7B801',this)" title="ë…¸ë‘"></button>
        <button class="color-btn" style="background:#7FB800" onclick="setColor('#7FB800',this)" title="ì´ˆë¡"></button>
        <button class="color-btn" style="background:#1D9A6C" onclick="setColor('#1D9A6C',this)" title="ì²­ë¡"></button>
        <button class="color-btn" style="background:#2563EB" onclick="setColor('#2563EB',this)" title="íŒŒë‘"></button>
        <button class="color-btn" style="background:#7C3AED" onclick="setColor('#7C3AED',this)" title="ë³´ë¼"></button>
        <button class="color-btn" style="background:#EC4899" onclick="setColor('#EC4899',this)" title="ë¶„í™"></button>
        <button class="color-btn" style="background:#374151" onclick="setColor('#374151',this)" title="ê²€ì •"></button>
        <button class="color-btn" style="background:#FFFFFF;border:2px solid #ddd" onclick="setColor('#FFFFFF',this)" title="í•˜ì–‘"></button>

        <div class="tool-sep"></div>
        <span class="size-label">ê°€ëŠ˜ê²Œ</span>
        <input type="range" id="size-slider" min="1" max="15" value="4">
        <span class="size-label">êµµê²Œ</span>

        <div class="tool-sep"></div>
        <button class="tool-btn" onclick="doSplatter()" title="ë¬¼ê° íŠ€ê¸°ê¸°">ğŸ’¦ ë¬¼ê°</button>
        <button class="tool-btn" onclick="doShapes()" title="ë„í˜• ë¿Œë¦¬ê¸°">ğŸ”· ë„í˜•</button>
        <button class="tool-btn" onclick="doSparkle()" title="ë°˜ì§ì´ ë¿Œë¦¬ê¸°">âœ¨ ë°˜ì§ì´</button>

        <div class="tool-sep"></div>
        <button class="tool-btn" id="analyze-btn" onclick="startAnalysis()">ğŸ” AI ë¶„ì„</button>
        <button class="tool-btn" onclick="clearCanvas()" title="ì´ˆê¸°í™”">ğŸ—‘ï¸</button>
    </div>
</div>

<!-- Share Toast -->
<div id="share-toast">ğŸŒŸ ê°¤ëŸ¬ë¦¬ì— ê³µìœ ë˜ì—ˆìŠµë‹ˆë‹¤!</div>

<!-- Loading -->
<div id="loading">
    <div class="spinner">ğŸ¨</div>
    <p id="loading-text">AI í‰ë¡ ê°€ê°€ ì‘í’ˆì„ ê°ìƒí•˜ê³  ìˆìŠµë‹ˆë‹¤<span class="dots"></span></p>
</div>

<!-- Analysis Modal -->
<div id="modal">
    <div id="modal-bg" onclick="closeModal()"></div>
    <div id="modal-card">
        <div id="modal-content"></div>
        <div class="modal-btns">
            <button id="share-btn" onclick="shareToGallery()">ğŸŒŸ ê°¤ëŸ¬ë¦¬ ê³µìœ </button>
            <button id="save-btn" onclick="saveResult()">ğŸ’¾ ì €ì¥í•˜ê¸°</button>
            <button id="email-btn" onclick="openEmailModal()">ğŸ“§ ì´ë©”ì¼</button>
            <button id="close-btn" onclick="closeModal()">ë‹«ê¸°</button>
        </div>
    </div>
</div>

<!-- Email Modal -->
<div id="email-modal">
    <div id="email-modal-bg" onclick="closeEmailModal()"></div>
    <div id="email-card">
        <h3>ğŸ“§ ë¶„ì„ ê²°ê³¼ ì´ë©”ì¼ë¡œ ë³´ë‚´ê¸°</h3>
        <p style="font-size:0.85em;color:#888;margin-bottom:14px;">ë‚™ì„œì™€ ë¶„ì„ ê²°ê³¼ê°€ ì´ë¯¸ì§€ë¡œ ì²¨ë¶€ë˜ì–´ ì „ì†¡ë©ë‹ˆë‹¤.</p>
        <input type="email" id="email-input" placeholder="ë°›ëŠ” ì‚¬ëŒ ì´ë©”ì¼ ì£¼ì†Œ" onkeydown="if(event.key==='Enter')sendEmail()">
        <div class="email-btns">
            <button id="cancel-email-btn" onclick="closeEmailModal()">ì·¨ì†Œ</button>
            <button id="send-email-btn" onclick="sendEmail()">ë³´ë‚´ê¸°</button>
        </div>
        <div id="email-status"></div>
    </div>
</div>

<!-- Doodle Detail Modal -->
<div id="detail-modal">
    <div id="detail-modal-bg" onclick="closeDetailModal()"></div>
    <div id="detail-card">
        <img id="detail-img" src="" alt="ë‚™ì„œ">
        <h3 id="detail-title"></h3>
        <div class="detail-likes" id="detail-likes"></div>
        <button id="detail-close-btn" onclick="closeDetailModal()">ë‹«ê¸°</button>
    </div>
</div>

<script>
// ============================================================
//  Proxy Configuration (injected by app.py)
// ============================================================
const PROXY_URL = 'http://localhost:__PROXY_PORT__';
const HAS_API_KEY = __HAS_API_KEY__;
const PROXY_API_URL = '__PROXY_API_URL__';

// ============================================================
//  Gallery State
// ============================================================
let galleryData = [];
let likedDoodles = JSON.parse(localStorage.getItem('doodle_liked') || '{}');

// ============================================================
//  Oil Painting Engine
// ============================================================
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const hint = document.getElementById('hint');
const sizeSlider = document.getElementById('size-slider');

let isDrawing = false;
let points = [];
let currentColor = '#E63946';
const BG_COLOR = '#FFFDF7';
let hasDrawn = false;

ctx.fillStyle = BG_COLOR;
ctx.fillRect(0, 0, canvas.width, canvas.height);

function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    const sx = canvas.width / rect.width;
    const sy = canvas.height / rect.height;
    if (e.touches && e.touches.length > 0) {
        return { x: (e.touches[0].clientX - rect.left) * sx, y: (e.touches[0].clientY - rect.top) * sy };
    }
    return { x: (e.clientX - rect.left) * sx, y: (e.clientY - rect.top) * sy };
}

function bs() { return parseInt(sizeSlider.value); }

function blob(x, y, size, color, alpha) {
    ctx.save();
    ctx.globalAlpha = alpha === undefined ? 0.88 : alpha;
    ctx.fillStyle = color || currentColor;
    ctx.beginPath();
    ctx.arc(x, y, Math.max(0.5, size), 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
}

function splatterDots(x, y, count, maxDist, maxSize, color) {
    for (let i = 0; i < count; i++) {
        const a = Math.random() * Math.PI * 2;
        const d = Math.pow(Math.random(), 0.65) * maxDist;
        blob(x + Math.cos(a) * d, y + Math.sin(a) * d, 0.4 + Math.random() * maxSize, color, 0.65 + Math.random() * 0.35);
    }
}

function onDown(e) {
    e.preventDefault();
    isDrawing = true;
    const p = getPos(e);
    points = [{ x: p.x, y: p.y, t: Date.now() }];
    if (!hasDrawn) { hasDrawn = true; hint.style.opacity = '0'; }
    const b = bs();
    blob(p.x, p.y, b * 1.3, currentColor, 0.85);
    splatterDots(p.x, p.y, 2 + Math.floor(Math.random() * 5), b * 9, b * 0.45, currentColor);
}

function onMove(e) {
    e.preventDefault();
    if (!isDrawing) return;
    const p = getPos(e);
    const now = Date.now();
    points.push({ x: p.x, y: p.y, t: now });
    if (points.length < 3) return;

    const n = points.length;
    const p0 = points[n - 3], p1 = points[n - 2], p2 = points[n - 1];
    const dx = p2.x - p1.x, dy = p2.y - p1.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const dt = Math.max(p2.t - p1.t, 1);
    const speed = dist / dt;
    const b = bs();
    const w = Math.max(0.8, b * 3.8 / (1 + speed * 0.4));

    const mx1 = (p0.x + p1.x) / 2, my1 = (p0.y + p1.y) / 2;
    const mx2 = (p1.x + p2.x) / 2, my2 = (p1.y + p2.y) / 2;

    ctx.save();
    ctx.globalAlpha = 0.82;
    ctx.strokeStyle = currentColor;
    ctx.lineWidth = w;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(mx1, my1);
    ctx.quadraticCurveTo(p1.x, p1.y, mx2, my2);
    ctx.stroke();
    ctx.restore();

    if (dist > 10 && Math.random() > 0.6) {
        splatterDots(p2.x, p2.y, 1 + Math.floor(Math.random() * 3), w * 5, w * 0.4, currentColor);
    }
}

function onUp() {
    if (isDrawing && points.length > 0) {
        const last = points[points.length - 1];
        const b = bs();
        splatterDots(last.x, last.y, 1 + Math.floor(Math.random() * 4), b * 7, b * 0.35, currentColor);
    }
    isDrawing = false;
    points = [];
}

canvas.addEventListener('mousedown', onDown);
canvas.addEventListener('mousemove', onMove);
canvas.addEventListener('mouseup', onUp);
canvas.addEventListener('mouseleave', onUp);
canvas.addEventListener('touchstart', onDown, { passive: false });
canvas.addEventListener('touchmove', onMove, { passive: false });
canvas.addEventListener('touchend', onUp);

// ============================================================
//  UI Functions
// ============================================================
function setColor(color, btn) {
    currentColor = color;
    document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
}

function clearCanvas() {
    ctx.fillStyle = BG_COLOR;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    hasDrawn = false;
    hint.style.opacity = '1';
}

// ============================================================
//  Creative Tools
// ============================================================
function hideHint() { if (!hasDrawn) { hasDrawn = true; hint.style.opacity = '0'; } }

function doSplatter() {
    hideHint();
    for (let s = 0; s < 3 + Math.floor(Math.random() * 3); s++) {
        const cx = 80 + Math.random() * (canvas.width - 160);
        const cy = 80 + Math.random() * (canvas.height - 160);
        const mainSize = 8 + Math.random() * 16;
        blob(cx, cy, mainSize, currentColor, 0.9);
        splatterDots(cx, cy, 18 + Math.floor(Math.random() * 22), 45 + Math.random() * 65, 6, currentColor);
        if (Math.random() > 0.3) {
            const dLen = 25 + Math.random() * 55;
            for (let dy = 0; dy < dLen; dy += 1.5) {
                const dw = Math.max(0.3, mainSize * 0.28 - dy * 0.06);
                if (dw < 0.3) break;
                ctx.save();
                ctx.globalAlpha = (1 - dy / dLen) * 0.8;
                ctx.fillStyle = currentColor;
                ctx.beginPath();
                ctx.arc(cx + (Math.random() - 0.5) * 3, cy + mainSize + dy, dw, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
    }
}

function doShapes() {
    hideHint();
    const types = ['circle', 'rect', 'triangle', 'diamond'];
    for (let i = 0; i < 5 + Math.floor(Math.random() * 4); i++) {
        const type = types[Math.floor(Math.random() * types.length)];
        const x = 60 + Math.random() * (canvas.width - 120);
        const y = 60 + Math.random() * (canvas.height - 120);
        const sz = 15 + Math.random() * 50;
        const filled = Math.random() > 0.45;
        ctx.save();
        ctx.strokeStyle = currentColor;
        ctx.fillStyle = currentColor;
        ctx.lineWidth = 2 + Math.random() * 3;
        ctx.globalAlpha = 0.65 + Math.random() * 0.35;
        if (type === 'circle') {
            ctx.beginPath(); ctx.arc(x, y, sz, 0, Math.PI * 2);
            filled ? ctx.fill() : ctx.stroke();
        } else if (type === 'rect') {
            filled ? ctx.fillRect(x - sz, y - sz * 0.6, sz * 2, sz * 1.2)
                   : ctx.strokeRect(x - sz, y - sz * 0.6, sz * 2, sz * 1.2);
        } else if (type === 'triangle') {
            ctx.beginPath(); ctx.moveTo(x, y - sz); ctx.lineTo(x - sz, y + sz); ctx.lineTo(x + sz, y + sz); ctx.closePath();
            filled ? ctx.fill() : ctx.stroke();
        } else {
            ctx.beginPath(); ctx.moveTo(x, y - sz); ctx.lineTo(x + sz, y); ctx.lineTo(x, y + sz); ctx.lineTo(x - sz, y); ctx.closePath();
            filled ? ctx.fill() : ctx.stroke();
        }
        ctx.restore();
    }
}

function doSparkle() {
    hideHint();
    for (let i = 0; i < 18; i++) {
        const x = 25 + Math.random() * (canvas.width - 50);
        const y = 25 + Math.random() * (canvas.height - 50);
        const sz = 4 + Math.random() * 14;
        const r = 200 + Math.floor(Math.random() * 55);
        const g = 200 + Math.floor(Math.random() * 55);
        const b = 50 + Math.floor(Math.random() * 205);
        const c = `rgb(${r},${g},${b})`;
        ctx.save();
        ctx.strokeStyle = c;
        ctx.lineWidth = 1.8;
        ctx.beginPath(); ctx.moveTo(x - sz, y); ctx.lineTo(x + sz, y); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x, y - sz); ctx.lineTo(x, y + sz); ctx.stroke();
        ctx.lineWidth = 1;
        const s2 = sz * 0.6;
        ctx.beginPath(); ctx.moveTo(x - s2, y - s2); ctx.lineTo(x + s2, y + s2); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x - s2, y + s2); ctx.lineTo(x + s2, y - s2); ctx.stroke();
        ctx.fillStyle = '#FFF';
        ctx.beginPath(); ctx.arc(x, y, 1.8, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
    }
}

// ============================================================
//  GPT API Integration
// ============================================================
function parseGPTResponse(text) {
    text = text.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
    return JSON.parse(text);
}

function formatGPTCritique(c) {
    const rating = Math.max(1, Math.min(5, parseInt(c.rating) || 4));
    const stars = '\u2605'.repeat(rating) + '\u2606'.repeat(5 - rating);
    const paragraphs = (c.interpretation || '')
        .split('\n\n')
        .filter(p => p.trim())
        .map(p => `<p>${p.trim()}</p>`)
        .join('');

    return `
        <h2>ğŸ–¼ï¸ AI ë¯¸ìˆ  í‰ë¡ </h2>
        <p style="text-align:center;margin:-8px 0 10px;"><span class="gpt-tag">GPT-4o-mini</span></p>
        <p class="title-work">\u300C${c.title || 'ë¬´ì œ'}\u300D</p>
        <p class="info-line"><span class="label">ğŸ­ ì˜ˆìˆ  ì‚¬ì¡°:</span> ${c.movement || 'ë¯¸ì •'} <span style="color:#999">(${c.movement_en || ''})</span></p>
        <p style="font-size:0.88em;color:#888;margin:-4px 0 6px 28px;font-style:italic;">${c.movement_desc || ''}</p>
        <p class="stars">${stars} <span style="font-size:0.55em;color:#999">(${rating}/5)</span></p>
        <div class="interpretation">
            <p><span class="label">ğŸ“œ ì‘í’ˆ í•´ì„</span></p>
            ${paragraphs}
        </div>
        <div class="emotion">
            <p><span class="label">ğŸ’­ ê°ì • ë¶„ì„</span></p>
            <p>${c.emotions || ''}</p>
        </div>
        <p class="info-line"><span class="label">ğŸ’° ì¶”ì • ê²½ë§¤ê°€:</span> ${c.price || 'ì¸¡ì • ë¶ˆê°€'}</p>
        <p class="info-line"><span class="label">ğŸ›ï¸ ì¶”ì²œ ì „ì‹œ:</span> ${c.exhibition || ''}</p>
        <p class="closing">"${c.closing || ''}"</p>
    `;
}

async function callGPT() {
    const imageData = canvas.toDataURL('image/jpeg', 0.7);
    const bodyPayload = JSON.stringify({ image: imageData });

    if (PROXY_API_URL) {
        try {
            const response = await fetch(PROXY_API_URL + '/api/analyze', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: bodyPayload
            });
            if (response.ok) {
                const data = await response.json();
                if (data.error) throw new Error(data.error);
                const critique = parseGPTResponse(data.critique);
                return formatGPTCritique(critique);
            }
            const err = await response.json().catch(() => ({}));
            throw new Error(err.error || 'Vercel proxy ìš”ì²­ ì‹¤íŒ¨');
        } catch (vercelError) {
            console.log('Vercel proxy failed:', vercelError.message);
        }
    }

    const response = await fetch(PROXY_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: bodyPayload
    });
    if (!response.ok) {
        const err = await response.json().catch(() => ({}));
        throw new Error(err.error || 'API ìš”ì²­ ì‹¤íŒ¨');
    }
    const data = await response.json();
    if (data.error) throw new Error(data.error);
    const critique = parseGPTResponse(data.critique);
    return formatGPTCritique(critique);
}

// ============================================================
//  Algorithmic Art Critic Engine (Fallback)
// ============================================================
const COLOR_DATA = {
    'ë¹¨ê°•': { adj: ['ì—´ì •ì ì¸', 'ë¶ˆíƒ€ì˜¤ë¥´ëŠ”', 'ê°•ë ¬í•œ', 'ë„ë°œì ì¸'], emotion: 'ì–µëˆŒë¦° ì—´ì •ê³¼ ìƒëª…ë ¥' },
    'ì£¼í™©': { adj: ['ë”°ëœ»í•œ', 'í™œê¸°ì°¬', 'í’ìš”ë¡œìš´', 'ë‚™ê´€ì ì¸'], emotion: 'ì‚¶ì˜ ì˜¨ê¸°ì™€ í¬ë§' },
    'ë…¸ë‘': { adj: ['ì°¬ë€í•œ', 'í¬ë§ì°¬', 'ë¹›ë‚˜ëŠ”', 'ìœ ì¾Œí•œ'], emotion: 'ìˆœìˆ˜í•œ ê¸°ì¨ê³¼ ì§€ì  í˜¸ê¸°ì‹¬' },
    'ì´ˆë¡': { adj: ['ìƒëª…ë ¥ ë„˜ì¹˜ëŠ”', 'í‰í™”ë¡œìš´', 'ìì—°ì ì¸', 'ì¡°í™”ë¡œìš´'], emotion: 'ì„±ì¥ê³¼ ì¹˜ìœ ì˜ ê°ˆë§' },
    'í•˜ëŠ˜ìƒ‰': { adj: ['ì²­ëª…í•œ', 'ëª½í™˜ì ì¸', 'ììœ ë¡œìš´', 'íˆ¬ëª…í•œ'], emotion: 'ë¬´í•œí•œ ììœ ì— ëŒ€í•œ ë™ê²½' },
    'íŒŒë‘': { adj: ['ì‹¬ì˜¤í•œ', 'ê³ ìš”í•œ', 'ê¹Šì€', 'ëª…ìƒì ì¸'], emotion: 'ë‚´ë©´ì˜ ê¹Šì€ ì‚¬ìƒ‰' },
    'ë³´ë¼': { adj: ['ì‹ ë¹„ë¡œìš´', 'ê³ ê·€í•œ', 'ì˜ì ì¸', 'ì´ˆì›”ì ì¸'], emotion: 'ì˜ì  ì´ˆì›”ê³¼ ì‹ ë¹„' },
    'ë¶„í™': { adj: ['ì‚¬ë‘ìŠ¤ëŸ¬ìš´', 'ëª½í™˜ì ì¸', 'ë¶€ë“œëŸ¬ìš´', 'ì„¬ì„¸í•œ'], emotion: 'ìˆœìˆ˜í•œ ì‚¬ë‘ê³¼ ê¿ˆ' },
    'ê²€ì •': { adj: ['ì‹¬ì—°ì˜', 'ì ˆëŒ€ì ì¸', 'ê·¼ì›ì ì¸', 'ë¬´í•œí•œ'], emotion: 'ì¡´ì¬ì˜ ê·¼ì›ì  ë¶ˆì•ˆ' },
    'í•˜ì–‘': { adj: ['ìˆœìˆ˜í•œ', 'ë¬´í•œí•œ', 'ì¹¨ë¬µì˜', 'ë¹„ì–´ìˆëŠ”'], emotion: 'ë¬´(ç„¡)ì˜ ìˆ­ê³ í•¨' },
    'íšŒìƒ‰': { adj: ['ì‚¬ìƒ‰ì ì¸', 'ì¤‘ë¦½ì ì¸', 'ë„ì‹œì ì¸', 'ëª…ìƒì˜'], emotion: 'í˜„ëŒ€ ì‚¬íšŒì˜ ê³ ë…' },
};

const MOVEMENTS = [
    ['ì‹ í‘œí˜„ì£¼ì˜', 'Neo-Expressionism', 'ê°•ë ¬í•œ ìƒ‰ì±„ì™€ ëŒ€ë‹´í•œ ë¶“ì§ˆë¡œ ë‚´ë©´ì˜ ê°ì •ì„ í­ë°œì ìœ¼ë¡œ í‘œí˜„í•œë‹¤'],
    ['ì¶”ìƒì  ê°ì„±ì£¼ì˜', 'Abstract Emotionalism', 'í˜•íƒœë¥¼ ì´ˆì›”í•˜ì—¬ ìˆœìˆ˜í•œ ê°ì •ì„ ì‹œê°ì ìœ¼ë¡œ ë²ˆì—­í•œë‹¤'],
    ['ë””ì§€í„¸ ì¸ìƒì£¼ì˜', 'Digital Impressionism', 'ë¹›ê³¼ ìƒ‰ì˜ ìˆœê°„ì  ì¸ìƒì„ ë””ì§€í„¸ ë§¤ì²´ë¡œ í¬ì°©í•œë‹¤'],
    ['í¬ìŠ¤íŠ¸ëª¨ë˜ ì›ì‹œì£¼ì˜', 'Postmodern Primitivism', 'ì›ì´ˆì  í‘œí˜„ì˜ ììœ ë¡œì›€ ì†ì— í˜„ëŒ€ì  ê°ì„±ì„ ë…¹ì—¬ë‚¸ë‹¤'],
    ['ì‚¬ì´ë²„ ë¯¸ë‹ˆë©€ë¦¬ì¦˜', 'Cyber Minimalism', 'ë””ì§€í„¸ ì‹œëŒ€ì˜ ì ˆì œëœ ì•„ë¦„ë‹¤ì›€ì„ ìµœì†Œí•œì˜ ìš”ì†Œë¡œ êµ¬í˜„í•œë‹¤'],
    ['ê°ê°ì  í•´ì²´ì£¼ì˜', 'Sensory Deconstructivism', 'ê¸°ì¡´ í˜•íƒœë¥¼ í•´ì²´í•˜ê³  ì¬ì¡°í•©í•˜ì—¬ ìƒˆë¡œìš´ ê°ê°ì„ ì°½ì¡°í•œë‹¤'],
    ['ì„œì •ì  ì¶”ìƒì£¼ì˜', 'Lyrical Abstractionism', 'ìŒì•…ì  ë¦¬ë“¬ê³¼ ì‹œì  ê°ì„±ì´ ìº”ë²„ìŠ¤ ìœ„ì—ì„œ ììœ ë¡­ê²Œ ì¶¤ì¶˜ë‹¤'],
    ['ëª…ìƒì  ìƒ‰ë©´ì£¼ì˜', 'Meditative Color-Fieldism', 'ê±°ëŒ€í•œ ìƒ‰ë©´ ì†ì—ì„œ ê´€ì¡°ì™€ ëª…ìƒì˜ ê²½í—˜ì„ ì´ëŒì–´ë‚¸ë‹¤'],
    ['ì´ˆí˜„ì‹¤ì  ìë™ê¸°ìˆ ë²•', 'Surrealist Automatism', 'ë¬´ì˜ì‹ì˜ íë¦„ì„ ë”°ë¼ ì†ì´ ì´ë„ëŠ” ëŒ€ë¡œ ìˆœìˆ˜í•˜ê²Œ í‘œí˜„í•œë‹¤'],
];

const NOUNS = ['ì˜í˜¼','ì‹œê°„','ê³µê°„','ì¡´ì¬','ê¸°ì–µ','ê¿ˆ','ì§„ì‹¤','í™˜ìƒ','ê³ ë…','ì—´ë§','ì¹¨ë¬µ','ìš¸ë¦¼','ì‹¬ì—°','ì—¬ëª…','í™©í˜¼','íŒŒë™','í”ì ','ë©”ì•„ë¦¬','ìˆ˜í‰ì„ ','ê²½ê³„','íŒŒí¸','ì”ìƒ'];
const METAPHORS = [
    'í­í’ìš° ì† í•œ ì¤„ê¸° ë¹›','ê¹Šì€ ë°”ë‹¤ ì† ì‚°í˜¸ì´ˆì˜ ì†ì‚­ì„','ìƒˆë²½ë…˜ ì´ìŠ¬ ìœ„ì— ë¹„ì¹œ ë¬´ì§€ê°œ',
    'ë°¤í•˜ëŠ˜ì„ ê°€ë¡œì§€ë¥´ëŠ” ìœ ì„±ìš°','ë´„ë‚ ì˜ ì²« ê½ƒìì´ ë°”ëŒì— ë‚ ë¦¬ëŠ” ìˆœê°„','ì•ˆê°œ ë‚€ í˜¸ìˆ˜ ìœ„ì˜ ê³ ìš”í•œ ë‹¬ë¹›',
    'í™”ì‚°ì´ í­ë°œí•˜ê¸° ì§ì „ì˜ ëŒ€ì§€ì˜ ë–¨ë¦¼','ì–´ë¦°ì•„ì´ê°€ ì²˜ìŒ ë°”ë‹¤ë¥¼ ë³¸ ìˆœê°„ì˜ ê²½ì´',
    'ê²¨ìš¸ ì°½ë¬¸ì— ë§ºíŒ ì„œë¦¬ê½ƒì˜ íŒ¨í„´','ìŠí˜€ì§„ ì •ì›ì— í™€ë¡œ í”¼ì–´ë‚œ ê½ƒ',
    'ì˜¤ë˜ëœ ì¶•ìŒê¸°ì—ì„œ í˜ëŸ¬ë‚˜ì˜¤ëŠ” ì™ˆì¸ ','ë¨¼ ì€í•˜ì—ì„œ ë‚ ì•„ì˜¨ ë¹›ì˜ ì”ìƒ',
    'ê¹Šì€ ë™êµ´ ì†ì—ì„œ ë°œê²¬í•œ ê³ ëŒ€ ë²½í™”','ìì •ì— ìš¸ë¦¬ëŠ” ì˜¤ë˜ëœ ì‹œê³„ì˜ ì¢…ì†Œë¦¬',
];
const MEANINGS = [
    'í˜„ëŒ€ ì‚¬íšŒì—ì„œ ê°œì¸ì˜ ì •ì²´ì„±ì´ íŒŒí¸í™”ë˜ëŠ” ê³¼ì •',
    'ë””ì§€í„¸ ì‹œëŒ€ ì† ì¸ê°„ ë³¸ì—°ì˜ ê°ì„±ì„ ë˜ì°¾ìœ¼ë ¤ëŠ” ëª¸ë¶€ë¦¼',
    'ì¡´ì¬ì™€ ë¶€ì¬ ì‚¬ì´ì˜ ê²½ê³„ì—ì„œ ëŠë¼ëŠ” ì‹¤ì¡´ì  ë¶ˆì•ˆ',
    'ìì—°ê³¼ ë¬¸ëª…ì˜ ì¶©ëŒ ì†ì—ì„œ í”¼ì–´ë‚˜ëŠ” ìƒˆë¡œìš´ ì¡°í™”',
    'ë¬´ì˜ì‹ì˜ ì‹¬ì¸µì—ì„œ ì†Ÿì•„ì˜¤ë¥´ëŠ” ì›ì´ˆì  ì°½ì¡° ë³¸ëŠ¥',
    'ì‹œê°„ì˜ íë¦„ ì†ì—ì„œ ë³€í•˜ì§€ ì•ŠëŠ” ê²ƒë“¤ì˜ ì˜ë¯¸',
    'ê¿ˆê³¼ í˜„ì‹¤ì˜ ê²½ê³„ê°€ í—ˆë¬¼ì–´ì§€ëŠ” ìˆœê°„ì˜ ì•„ë¦„ë‹¤ì›€',
    'ì¸ê°„ ê´€ê³„ì˜ ë³µì¡í•œ ê·¸ë¬¼ë§ ì† ì§„ì •í•œ ì—°ê²°ì˜ ì˜ë¯¸',
];
const CLOSINGS = [
    'ì´ ì‘í’ˆ ì•ì—ì„œ ëˆˆì„ ê°ê³  5ë¶„ê°„ ëª…ìƒí•  ê²ƒì„ ê°•ë ¥íˆ ê¶Œí•©ë‹ˆë‹¤.',
    'ë³´ëŠ” ì´ì˜ ì˜í˜¼ì´ ì¶©ë¶„íˆ ì„±ìˆ™í–ˆì„ ë•Œ, ì´ ì‘í’ˆì˜ ì§„ì •í•œ ì˜ë¯¸ê°€ ë“œëŸ¬ë‚  ê²ƒì…ë‹ˆë‹¤.',
    '21ì„¸ê¸° ë””ì§€í„¸ ì•„íŠ¸ì˜ ìƒˆë¡œìš´ ì¥ì„ ì—¬ëŠ” ê¸°ë…ë¹„ì  ì‘í’ˆì…ë‹ˆë‹¤.',
    'ìˆ˜ë°± ë…„ í›„ ë¯¸ë˜ì˜ ë¯¸ìˆ ì‚¬í•™ìë“¤ì´ ì´ ì‘í’ˆì„ ì¬ë°œê²¬í•˜ê²Œ ë  ê²ƒì…ë‹ˆë‹¤.',
    'ì´ ì‘í’ˆì„ ì´í•´í•˜ì§€ ëª»í•œë‹¤ë©´, ê·¸ê²ƒì€ ë‹¹ì‹ ì˜ ì˜í˜¼ì´ ì•„ì§ ì¤€ë¹„ë˜ì§€ ì•Šì€ ê²ƒì…ë‹ˆë‹¤.',
    'í”„ë‘ìŠ¤ ë£¨ë¸Œë¥´ ë°•ë¬¼ê´€ ê´€ê³„ìì—ê²Œ ì¦‰ì‹œ ì—°ë½í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤.',
    'ì´ ì‘í’ˆì˜ ê°€ì¹˜ëŠ” ê¸ˆì „ìœ¼ë¡œ í™˜ì‚°í•  ìˆ˜ ì—†ìœ¼ë‚˜, êµ³ì´ í•˜ìë©´ ìƒë‹¹í•©ë‹ˆë‹¤.',
    'ì‘ê°€ì—ê²Œ ë‹¹ì¥ í›„ì†ì‘ì„ ì˜ë¢°í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤. ì²œì¬ëŠ” ê¸°ë‹¤ë ¤ì£¼ì§€ ì•ŠìŠµë‹ˆë‹¤.',
];
const EXHIBITIONS = [
    'ì œ{n}íšŒ êµ­ì œ ë””ì§€í„¸ ì˜í˜¼ ì „ì‹œíšŒ','ì„œìš¸ í˜„ëŒ€ë¯¸ìˆ  ë¹„ì—”ë‚ ë ˆ',
    'êµ­ë¦½í˜„ëŒ€ë¯¸ìˆ ê´€ íŠ¹ë³„ê¸°íšì „ ã€Œì¡´ì¬ì˜ ê²½ê³„ã€','ë² ë‹ˆìŠ¤ ë¹„ì—”ë‚ ë ˆ í•œêµ­ê´€',
    'ë‰´ìš• MoMA ì‹ ì§„ì‘ê°€ì „','ëŸ°ë˜ í…Œì´íŠ¸ ëª¨ë˜ ì•„ì‹œì•„ í˜„ëŒ€ë¯¸ìˆ  íŠ¹ë³„ì „',
    'ë„ì¿„ ëª¨ë¦¬ë¯¸ìˆ ê´€ ë””ì§€í„¸ ì•„íŠ¸ í˜ìŠ¤í‹°ë²Œ','íŒŒë¦¬ íí”¼ë‘ì„¼í„° ì´ˆëŒ€ì „',
];

function pick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

function josa(word, cons, vowel) {
    const c = word.charCodeAt(word.length - 1);
    if (c >= 0xAC00 && c <= 0xD7A3) return word + ((c - 0xAC00) % 28 !== 0 ? cons : vowel);
    return word + cons;
}

function getColorName(r, g, b) {
    r /= 255; g /= 255; b /= 255;
    const mx = Math.max(r, g, b), mn = Math.min(r, g, b), d = mx - mn;
    let h = 0, s = mx === 0 ? 0 : d / mx, v = mx;
    if (d !== 0) {
        if (mx === r) h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
        else if (mx === g) h = ((b - r) / d + 2) / 6;
        else h = ((r - g) / d + 4) / 6;
    }
    h *= 360;
    if (v < 0.15) return 'ê²€ì •';
    if (s < 0.12) return v > 0.85 ? 'í•˜ì–‘' : 'íšŒìƒ‰';
    if (h < 15 || h >= 345) return 'ë¹¨ê°•';
    if (h < 40) return 'ì£¼í™©';
    if (h < 65) return 'ë…¸ë‘';
    if (h < 160) return 'ì´ˆë¡';
    if (h < 200) return 'í•˜ëŠ˜ìƒ‰';
    if (h < 260) return 'íŒŒë‘';
    if (h < 300) return 'ë³´ë¼';
    return 'ë¶„í™';
}

function analyzeCanvas() {
    const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const d = img.data;
    const total = canvas.width * canvas.height;
    const bgR = d[0], bgG = d[1], bgB = d[2];
    let drawn = 0;
    const cc = {};
    const quads = [0, 0, 0, 0];
    const mw = canvas.width / 2, mh = canvas.height / 2;

    for (let i = 0; i < d.length; i += 16) {
        const px = ((i / 4) % canvas.width);
        const py = Math.floor((i / 4) / canvas.width);
        const r = d[i], g = d[i + 1], b = d[i + 2];
        if (Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB) > 30) {
            drawn++;
            const name = getColorName(r, g, b);
            cc[name] = (cc[name] || 0) + 1;
            quads[(py < mh ? 0 : 2) + (px < mw ? 0 : 1)]++;
        }
    }

    const sampledTotal = total / 4;
    const coverage = drawn / sampledTotal;
    const sorted = Object.entries(cc).sort((a, b) => b[1] - a[1]);
    const domColors = sorted.slice(0, 3).map(c => c[0]);
    if (domColors.length === 0) domColors.push('ê²€ì •');

    const warm = ['ë¹¨ê°•', 'ì£¼í™©', 'ë…¸ë‘', 'ë¶„í™'].reduce((s, c) => s + (cc[c] || 0), 0);
    const cool = ['íŒŒë‘', 'í•˜ëŠ˜ìƒ‰', 'ì´ˆë¡', 'ë³´ë¼'].reduce((s, c) => s + (cc[c] || 0), 0);

    return {
        coverage,
        domColors,
        colorVariety: Object.keys(cc).length,
        warmth: warm / Math.max(warm + cool, 1),
        maxQ: quads.indexOf(Math.max(...quads)),
    };
}

function generateCritique(f) {
    if (f.coverage < 0.008) return emptyResponse();

    const dc = f.domColors[0];
    const cd = COLOR_DATA[dc] || COLOR_DATA['ê²€ì •'];
    const adj = pick(cd.adj);
    const n1 = pick(NOUNS);
    let n2 = pick(NOUNS); while (n2 === n1) n2 = pick(NOUNS);
    const title = pick([
        `${adj} ${n1}ì˜ ${n2}`, `${n1} ì†ì˜ ${adj} ${n2}`,
        `${adj} ${n1}`, `${josa(n1,'ê³¼','ì™€')} ${n2} ì‚¬ì´ì—ì„œ`, `${adj} ${n1}ì˜ ë…¸ë˜`,
    ]);

    let mi;
    if (f.coverage > 0.35 && f.colorVariety > 2) mi = pick([0, 5, 8]);
    else if (f.coverage < 0.08) mi = pick([4, 7]);
    else if (f.colorVariety >= 4) mi = pick([2, 6]);
    else mi = Math.floor(Math.random() * MOVEMENTS.length);
    const mv = MOVEMENTS[mi];

    let score = 3;
    if (f.coverage > 0.25) score += 0.5;
    if (f.colorVariety >= 3) score += 0.5;
    if (f.coverage > 0.05) score += 0.5;
    score += (Math.random() - 0.5);
    const rating = Math.max(1, Math.min(5, Math.round(score)));
    const stars = '\u2605'.repeat(rating) + '\u2606'.repeat(5 - rating);

    let covD;
    if (f.coverage > 0.4) covD = 'ìº”ë²„ìŠ¤ë¥¼ ê°€ë“ ì±„ìš°ëŠ” ëŒ€ë‹´í•œ í‘œí˜„ë ¥';
    else if (f.coverage > 0.15) covD = 'ì ì ˆí•œ ì—¬ë°±ê³¼ ì±„ì›€ì˜ ì¡°í™”';
    else if (f.coverage > 0.04) covD = 'ì ˆì œëœ ë¶“ë†€ë¦¼ ì† ê¹Šì€ ìš¸ë¦¼';
    else covD = 'ê·¹ë‹¨ì  ë¯¸ë‹ˆë©€ë¦¬ì¦˜ì˜ ìš©ê¸° ìˆëŠ” ì„ íƒ';

    const qN = ['ì¢Œìƒë‹¨', 'ìš°ìƒë‹¨', 'ì¢Œí•˜ë‹¨', 'ìš°í•˜ë‹¨'];
    const qM = ['ê³¼ê±°ì˜ ê¸°ì–µê³¼ ì´ìƒí–¥ì„ í–¥í•œ ì‹œì„ ', 'ë¯¸ë˜ë¥¼ í–¥í•œ í¬ë§ê³¼ ë„ì „ ì •ì‹ ', 'ë¬´ì˜ì‹ì˜ ì‹¬ì¸µê³¼ ê°ì¶°ì§„ ê°ì •', 'í˜„ì‹¤ê³¼ì˜ ì¡°ìš°, êµ¬ì²´ì  í–‰ë™ì— ëŒ€í•œ ì˜ì§€'];
    let colD = f.domColors.length >= 2
        ? `${josa(f.domColors[0],'ê³¼','ì™€')} ${f.domColors[1]}ì˜ ëŒ€ë¹„ëŠ” ì‘ê°€ ë‚´ë©´ì˜ ì´ì¤‘ì„±ì„ ë“œëŸ¬ëƒ…ë‹ˆë‹¤`
        : `${dc}ì˜ ì§€ë°°ì  ì‚¬ìš©ì€ ì‘ê°€ì˜ ê°•í•œ ì˜ì§€ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤`;
    let tempD;
    if (f.warmth > 0.6) tempD = 'ë”°ëœ»í•œ ìƒ‰ì¡°ê°€ ì§€ë°°í•˜ëŠ” í™”ë©´ì—ì„œ ì‘ê°€ì˜ ì—´ì •ê³¼ ìƒëª…ì— ëŒ€í•œ ì‚¬ë‘ì´ ëŠê»´ì§‘ë‹ˆë‹¤.';
    else if (f.warmth < 0.3) tempD = 'ì°¨ê°€ìš´ ìƒ‰ì¡° ì†ì—ì„œ ê¹Šì€ ì‚¬ìƒ‰ê³¼ ë‚´ë©´ìœ¼ë¡œì˜ ì—¬í–‰ì´ ì‹œì‘ë©ë‹ˆë‹¤.';
    else tempD = 'ë”°ëœ»í•¨ê³¼ ì°¨ê°€ì›€ì´ ê³µì¡´í•˜ëŠ” ìƒ‰ì±„ëŠ” ì‚¶ì˜ ì–‘ë©´ì„±ì„ ì€ìœ í•©ë‹ˆë‹¤.';

    const met = pick(METAPHORS), mean = pick(MEANINGS);

    const interp = `ì´ ì‘í’ˆì—ì„œ ê°€ì¥ ë¨¼ì € ëˆˆì— ë“¤ì–´ì˜¤ëŠ” ê²ƒì€ ${adj} ${dc}ì˜ ì‚¬ìš©ì…ë‹ˆë‹¤. ì—¬ê¸°ì„œ ëŠê»´ì§€ëŠ” ${josa(covD,'ì€','ëŠ”')} ë§ˆì¹˜ ${josa(met,'ì„','ë¥¼')} ì—°ìƒì‹œí‚¤ë©°, ë³´ëŠ” ì´ì˜ ë§ˆìŒì„ ê¹Šì€ ê³³ìœ¼ë¡œ ì´ë•ë‹ˆë‹¤.</p><p>${colD}. íŠ¹íˆ ${qN[f.maxQ]}ì— ì§‘ì¤‘ëœ í‘œí˜„ì€ ${josa(qM[f.maxQ],'ì„','ë¥¼')} ìƒì§•í•˜ëŠ” ê²ƒìœ¼ë¡œ í•´ì„ë©ë‹ˆë‹¤.</p><p>${tempD} ì´ ëª¨ë“  ìš”ì†Œê°€ ì–´ìš°ëŸ¬ì ¸ ${josa(mean,'ì„','ë¥¼')} íƒêµ¬í•˜ëŠ” ê¹Šì´ ìˆëŠ” ì‘í’ˆì´ ì™„ì„±ë˜ì—ˆìŠµë‹ˆë‹¤.</p><p>${mv[0]}ì˜ ê´€ì ì—ì„œ, ${mv[2]}ëŠ” ì´ ì‚¬ì¡°ì˜ í•µì‹¬ ê°€ì¹˜ë¥¼ ì´ ì‘í’ˆì€ ì™„ë²½í•˜ê²Œ êµ¬í˜„í•˜ê³  ìˆìŠµë‹ˆë‹¤.`;

    const emos = f.domColors.slice(0, 3).map(c => (COLOR_DATA[c] || COLOR_DATA['ê²€ì •']).emotion).join(', ');

    let price;
    if (f.coverage > 0.4 && f.colorVariety > 3) price = `\u20A9${Math.floor(Math.random() * 99 + 1)}ì–µ ${Math.floor(Math.random() * 9000 + 1000)}ë§Œì› (í¬ë¦¬ìŠ¤í‹° ê²½ë§¤ ì¶”ì •ê°€)`;
    else if (f.coverage > 0.15) price = `\u20A9${(Math.floor(Math.random() * 99 + 1) * 100).toLocaleString()}ë§Œì› (ì†Œë”ë¹„ ì¶”ì •ê°€)`;
    else if (f.coverage > 0.04) price = `\u20A9${(Math.floor(Math.random() * 99 + 1) * 10).toLocaleString()}ë§Œì› (ê°¤ëŸ¬ë¦¬ íŒë§¤ê°€)`;
    else price = 'ì¸¡ì • ë¶ˆê°€ (ì´ ì‘í’ˆì˜ ê°€ì¹˜ëŠ” ë¬¼ì§ˆì„ ì´ˆì›”í•©ë‹ˆë‹¤)';

    const exh = pick(EXHIBITIONS).replace('{n}', Math.floor(Math.random() * 15 + 1));
    const cls = pick(CLOSINGS);

    return `
        <h2>ğŸ–¼ï¸ AI ë¯¸ìˆ  í‰ë¡ </h2>
        <p class="title-work">\u300C${title}\u300D</p>
        <p class="info-line"><span class="label">ğŸ­ ì˜ˆìˆ  ì‚¬ì¡°:</span> ${mv[0]} <span style="color:#999">(${mv[1]})</span></p>
        <p style="font-size:0.88em;color:#888;margin:-4px 0 6px 28px;font-style:italic;">${mv[2]}</p>
        <p class="stars">${stars} <span style="font-size:0.55em;color:#999">(${rating}/5)</span></p>
        <div class="interpretation">
            <p><span class="label">ğŸ“œ ì‘í’ˆ í•´ì„</span></p>
            <p>${interp}</p>
        </div>
        <div class="emotion">
            <p><span class="label">ğŸ’­ ê°ì • ë¶„ì„</span></p>
            <p>ì´ ì‘í’ˆì—ì„œ ì½íˆëŠ” ì£¼ìš” ê°ì •ì€ <b>${emos}</b>ì…ë‹ˆë‹¤.</p>
        </div>
        <p class="info-line"><span class="label">ğŸ’° ì¶”ì • ê²½ë§¤ê°€:</span> ${price}</p>
        <p class="info-line"><span class="label">ğŸ›ï¸ ì¶”ì²œ ì „ì‹œ:</span> ${exh}</p>
        <p class="closing">"${cls}"</p>
    `;
}

function emptyResponse() {
    const t = [
        [`ë¬´(ç„¡)`, 'ê·¹í•œ ë¯¸ë‹ˆë©€ë¦¬ì¦˜', 'Extreme Minimalism', '\u2605\u2605\u2605\u2605\u2605', 5,
         'ì•„ë¬´ê²ƒë„ ê·¸ë¦¬ì§€ ì•Šì•˜ë‹¤... ì´ê²ƒì´ì•¼ë§ë¡œ ê°€ì¥ ëŒ€ë‹´í•œ ì˜ˆìˆ ì  ì„ ì–¸ì…ë‹ˆë‹¤! ë¹ˆ ìº”ë²„ìŠ¤ëŠ” ë¬´í•œí•œ ê°€ëŠ¥ì„±ì˜ ê³µê°„ì´ë©°, ì‘ê°€ëŠ” ê·¸ ê°€ëŠ¥ì„± ìì²´ë¥¼ ì‘í’ˆìœ¼ë¡œ ì œì‹œí–ˆìŠµë‹ˆë‹¤. ë§ˆë¥´ì…€ ë’¤ìƒ¹ì´ ë³€ê¸°ë¥¼ ì „ì‹œí•œ ì´í›„ë¡œ ì´í† ë¡ í˜ëª…ì ì¸ ì‘í’ˆì€ ì—†ì—ˆìŠµë‹ˆë‹¤.',
         '\u20A9\u221E (ê°’ì„ ë§¤ê¸¸ ìˆ˜ ì—†ìŒ)', 'ì•„ë¬´ê²ƒë„ ê·¸ë¦¬ì§€ ì•Šì„ ìš©ê¸°. ê·¸ê²ƒì´ ì§„ì •í•œ ì˜ˆìˆ ì…ë‹ˆë‹¤.'],
        [`ì‹œì‘ ì „ì˜ ì¹¨ë¬µ`, 'ì¡´ì¬ë¡ ì  ê³µë°±ì£¼ì˜', 'Ontological Voidism', '\u2605\u2605\u2605\u2605\u2606', 4,
         'ìˆœë°±ì˜ ìº”ë²„ìŠ¤ê°€ ë§í•©ë‹ˆë‹¤... "ë‚˜ë¥¼ ì±„ì›Œì£¼ì„¸ìš”." í•˜ì§€ë§Œ ì‘ê°€ëŠ” ì˜ë„ì ìœ¼ë¡œ ì´ ìš”ì²­ì„ ê±°ë¶€í–ˆìŠµë‹ˆë‹¤. ë¹„ì–´ìˆìŒ ìì²´ê°€ ê°€ì¥ ì¶©ë§Œí•œ í‘œí˜„ì´ ë  ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì„ ì¦ëª…í•˜ëŠ” ì‘í’ˆì…ë‹ˆë‹¤.',
         'ê°ì •ì„ ìœ„í•´ ë¨¼ì € ë¬´ì–¸ê°€ë¥¼ ê·¸ë ¤ì£¼ì„¸ìš” \uD83D\uDE0A', 'ë¨¼ì € ë‚™ì„œë¥¼ í•´ë³´ì„¸ìš”! ë‹¹ì‹ ì˜ ë‚´ë©´ì—ëŠ” ë¶„ëª… í‘œí˜„í•˜ê³  ì‹¶ì€ ë¬´ì–¸ê°€ê°€ ìˆì„ ê±°ì˜ˆìš”.'],
    ];
    const e = pick(t);
    return `
        <h2>ğŸ–¼ï¸ AI ë¯¸ìˆ  í‰ë¡ </h2>
        <p class="title-work">\u300C${e[0]}\u300D</p>
        <p class="info-line"><span class="label">ğŸ­ ì˜ˆìˆ  ì‚¬ì¡°:</span> ${e[1]} <span style="color:#999">(${e[2]})</span></p>
        <p class="stars">${e[3]} <span style="font-size:0.55em;color:#999">(${e[4]}/5)</span></p>
        <div class="interpretation"><p>${e[5]}</p></div>
        <p class="info-line"><span class="label">ğŸ’° ì¶”ì • ê²½ë§¤ê°€:</span> ${e[6]}</p>
        <p class="closing">"${e[7]}"</p>
    `;
}

// ============================================================
//  Analysis Trigger (GPT with Algorithmic Fallback)
// ============================================================
async function startAnalysis() {
    const loading = document.getElementById('loading');
    const loadingText = document.getElementById('loading-text');
    const features = analyzeCanvas();

    if (HAS_API_KEY && features.coverage >= 0.008) {
        loadingText.innerHTML = 'GPTê°€ ì‘í’ˆì„ ê°ìƒí•˜ê³  ìˆìŠµë‹ˆë‹¤<span class="dots"></span>';
        loading.classList.add('show');
        try {
            const html = await callGPT();
            document.getElementById('modal-content').innerHTML = html;
            loading.classList.remove('show');
            document.getElementById('share-btn').disabled = false;
            document.getElementById('share-btn').textContent = 'ğŸŒŸ ê°¤ëŸ¬ë¦¬ ê³µìœ ';
            document.getElementById('modal').classList.add('show');
            return;
        } catch (e) {
            console.error('GPT error:', e);
            loadingText.innerHTML = 'GPT ì—°ê²° ì‹¤íŒ¨... ì•Œê³ ë¦¬ì¦˜ ë¶„ì„ìœ¼ë¡œ ì „í™˜í•©ë‹ˆë‹¤<span class="dots"></span>';
            await new Promise(r => setTimeout(r, 1500));
        }
    } else {
        loadingText.innerHTML = 'AI í‰ë¡ ê°€ê°€ ì‘í’ˆì„ ê°ìƒí•˜ê³  ìˆìŠµë‹ˆë‹¤<span class="dots"></span>';
        loading.classList.add('show');
    }

    await new Promise(r => setTimeout(r, 1800 + Math.random() * 800));
    const critique = generateCritique(features);
    document.getElementById('modal-content').innerHTML = critique;
    loading.classList.remove('show');
    document.getElementById('share-btn').disabled = false;
    document.getElementById('share-btn').textContent = 'ğŸŒŸ ê°¤ëŸ¬ë¦¬ ê³µìœ ';
    document.getElementById('modal').classList.add('show');
}

function closeModal() {
    document.getElementById('modal').classList.remove('show');
}

// ============================================================
//  Gallery Functions
// ============================================================
function generateThumbnail() {
    const tc = document.createElement('canvas');
    tc.width = 240;
    tc.height = Math.round(240 * canvas.height / canvas.width);
    const tctx = tc.getContext('2d');
    tctx.drawImage(canvas, 0, 0, tc.width, tc.height);
    return tc.toDataURL('image/jpeg', 0.65);
}

function getAnalysisTitle() {
    const mc = document.getElementById('modal-content');
    const titleEl = mc.querySelector('.title-work');
    if (titleEl) {
        let t = titleEl.textContent.trim();
        t = t.replace(/[ã€Œã€ã€ã€]/g, '').trim();
        return t || 'ë¬´ì œ';
    }
    return 'ë¬´ì œ';
}

async function galleryFetch(path, options) {
    // Try Vercel proxy first (single /api/gallery endpoint with action)
    if (PROXY_API_URL) {
        try {
            let vercelOpts = { ...options };
            if (path === '/gallery' && (!options || options.method === 'GET')) {
                vercelOpts = { method: 'GET' };
            } else if (path === '/gallery/save') {
                const body = JSON.parse(options.body);
                vercelOpts = {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'save', ...body })
                };
            } else if (path === '/gallery/like') {
                const body = JSON.parse(options.body);
                vercelOpts = {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'like', ...body })
                };
            } else if (path === '/gallery/unlike') {
                const body = JSON.parse(options.body);
                vercelOpts = {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'unlike', ...body })
                };
            }
            const resp = await fetch(PROXY_API_URL + '/api/gallery', vercelOpts);
            if (resp.ok) return await resp.json();
        } catch (e) {
            console.log('Vercel gallery failed:', e.message);
        }
    }
    // Fall back to local proxy (separate path endpoints)
    const resp = await fetch(PROXY_URL + path, options);
    return await resp.json();
}

async function loadGallery() {
    try {
        const data = await galleryFetch('/gallery', { method: 'GET' });
        galleryData = data.gallery || [];
        renderGallery();
    } catch (e) {
        console.log('Gallery load failed:', e.message);
    }
}

function renderGallery() {
    const list = document.getElementById('gallery-list');
    const empty = document.getElementById('gallery-empty');
    const count = document.getElementById('gallery-count');

    count.textContent = galleryData.length;

    if (galleryData.length === 0) {
        empty.style.display = 'block';
        // Remove all gallery items but keep empty div
        list.querySelectorAll('.gallery-item').forEach(el => el.remove());
        return;
    }

    empty.style.display = 'none';

    // Build HTML
    let html = '';
    galleryData.forEach((item, idx) => {
        const rank = idx + 1;
        let rankClass = 'rank-n';
        if (rank === 1) rankClass = 'rank-1';
        else if (rank === 2) rankClass = 'rank-2';
        else if (rank === 3) rankClass = 'rank-3';

        const isLiked = !!likedDoodles[item.id];
        const likedClass = isLiked ? ' liked' : '';

        const timeAgo = getTimeAgo(item.created_at);

        html += `
            <div class="gallery-item" data-id="${item.id}">
                <div class="gallery-item-header">
                    <div class="rank-badge ${rankClass}">${rank}</div>
                    <div class="gallery-item-title" title="${item.title}">${item.title}</div>
                </div>
                <img class="gallery-thumb" src="${item.image}" alt="${item.title}" onclick="openDetail('${item.id}')">
                <div class="gallery-item-footer">
                    <span class="gallery-time">${timeAgo}</span>
                    <button class="like-btn${likedClass}" onclick="toggleLike('${item.id}', this)" title="ì¶”ì²œ">
                        <span class="like-icon">${isLiked ? 'â¤ï¸' : 'ğŸ¤'}</span>
                        <span class="like-count">${item.likes || 0}</span>
                    </button>
                </div>
            </div>
        `;
    });

    // Replace content (keep empty div)
    list.querySelectorAll('.gallery-item').forEach(el => el.remove());
    list.insertAdjacentHTML('beforeend', html);
}

function getTimeAgo(timestamp) {
    const now = Date.now() / 1000;
    const diff = now - timestamp;
    if (diff < 60) return 'ë°©ê¸ˆ ì „';
    if (diff < 3600) return `${Math.floor(diff / 60)}ë¶„ ì „`;
    if (diff < 86400) return `${Math.floor(diff / 3600)}ì‹œê°„ ì „`;
    if (diff < 604800) return `${Math.floor(diff / 86400)}ì¼ ì „`;
    return new Date(timestamp * 1000).toLocaleDateString('ko-KR', { month: 'short', day: 'numeric' });
}

async function shareToGallery() {
    const btn = document.getElementById('share-btn');
    btn.disabled = true;
    btn.textContent = 'ê³µìœ  ì¤‘...';

    try {
        const thumbnail = generateThumbnail();
        const title = getAnalysisTitle();

        const data = await galleryFetch('/gallery/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ image: thumbnail, title: title })
        });

        if (data.success) {
            btn.textContent = 'âœ… ê³µìœ  ì™„ë£Œ!';
            showToast('ğŸŒŸ ê°¤ëŸ¬ë¦¬ì— ê³µìœ ë˜ì—ˆìŠµë‹ˆë‹¤!');
            await loadGallery();
        } else {
            throw new Error(data.error || 'ê³µìœ  ì‹¤íŒ¨');
        }
    } catch (e) {
        btn.textContent = 'âŒ ì‹¤íŒ¨';
        console.error('Share failed:', e);
        setTimeout(() => {
            btn.disabled = false;
            btn.textContent = 'ğŸŒŸ ê°¤ëŸ¬ë¦¬ ê³µìœ ';
        }, 2000);
    }
}

async function toggleLike(id, btn) {
    const isLiked = !!likedDoodles[id];
    const endpoint = isLiked ? '/gallery/unlike' : '/gallery/like';

    try {
        const data = await galleryFetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ id: id })
        });

        if (data.success) {
            if (isLiked) {
                delete likedDoodles[id];
                btn.classList.remove('liked');
                btn.querySelector('.like-icon').textContent = 'ğŸ¤';
            } else {
                likedDoodles[id] = true;
                btn.classList.add('liked');
                btn.classList.add('just-liked');
                btn.querySelector('.like-icon').textContent = 'â¤ï¸';
                setTimeout(() => btn.classList.remove('just-liked'), 500);
            }
            btn.querySelector('.like-count').textContent = data.likes;
            localStorage.setItem('doodle_liked', JSON.stringify(likedDoodles));

            // Update local data and re-sort
            const item = galleryData.find(g => g.id === id);
            if (item) item.likes = data.likes;
            galleryData.sort((a, b) => (b.likes || 0) - (a.likes || 0) || (b.created_at || 0) - (a.created_at || 0));
            renderGallery();
        }
    } catch (e) {
        console.error('Like failed:', e);
    }
}

function openDetail(id) {
    const item = galleryData.find(g => g.id === id);
    if (!item) return;
    document.getElementById('detail-img').src = item.image;
    document.getElementById('detail-title').textContent = `ã€Œ${item.title}ã€`;
    document.getElementById('detail-likes').textContent = `â¤ï¸ ${item.likes || 0}ê°œì˜ ì¶”ì²œ`;
    document.getElementById('detail-modal').classList.add('show');
}

function closeDetailModal() {
    document.getElementById('detail-modal').classList.remove('show');
}

function showToast(msg) {
    const toast = document.getElementById('share-toast');
    toast.textContent = msg;
    toast.classList.add('show');
    setTimeout(() => toast.classList.remove('show'), 2500);
}

// ============================================================
//  Save Result (Combined Doodle + Analysis PNG)
// ============================================================
function wrapLines(ctx, text, maxW) {
    const lines = [];
    const paras = text.split('\n');
    for (const para of paras) {
        if (!para.trim()) { lines.push(''); continue; }
        let line = '';
        for (const ch of para) {
            const test = line + ch;
            if (ctx.measureText(test).width > maxW && line) {
                lines.push(line); line = ch;
            } else line = test;
        }
        if (line) lines.push(line);
    }
    return lines;
}

function drawRoundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r);
    ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
    ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r);
    ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y);
    ctx.closePath();
}

function saveResult() {
    const mc = document.getElementById('modal-content');
    const W = 960, pad = 40, tw = W - pad * 2;
    const ff = '"Apple SD Gothic Neo","Malgun Gothic","Noto Sans KR",sans-serif';
    const bodyF = `15px ${ff}`, smallF = `13px ${ff}`, labelF = `bold 14px ${ff}`;

    const title = mc.querySelector('.title-work')?.textContent?.trim() || 'ë¬´ì œ';
    const infos = [...mc.querySelectorAll('.info-line')];
    const movementLine = infos[0]?.textContent?.trim() || '';
    const priceLine = infos.find(el => el.textContent.includes('ê²½ë§¤ê°€'))?.textContent?.trim() || '';
    const exhibLine = infos.find(el => el.textContent.includes('ì „ì‹œ'))?.textContent?.trim() || '';
    const starsText = mc.querySelector('.stars')?.textContent?.trim() || '';
    const interpEl = mc.querySelector('.interpretation');
    const interpText = interpEl ? [...interpEl.querySelectorAll('p')].filter(p => !p.querySelector('.label')).map(p => p.textContent.trim()).join('\n\n') : '';
    const emotionEl = mc.querySelector('.emotion');
    const emotionText = emotionEl ? [...emotionEl.querySelectorAll('p')].filter(p => !p.querySelector('.label')).map(p => p.textContent.trim()).join(' ') : '';
    const closing = mc.querySelector('.closing')?.textContent?.trim() || '';
    const isGPT = !!mc.querySelector('.gpt-tag');

    const m = document.createElement('canvas').getContext('2d');
    m.font = bodyF;
    const interpLines = wrapLines(m, interpText, tw - 40);
    const emotionLines = wrapLines(m, emotionText, tw - 40);
    m.font = `italic 15px ${ff}`;
    const closingLines = wrapLines(m, closing, tw - 60);

    const dW = 840, dH = Math.round(840 * canvas.height / canvas.width);

    let H = pad;
    H += 40;
    if (isGPT) H += 22;
    H += 15 + dH + 20;
    H += 35;
    H += 22;
    H += 40;
    H += 15;
    H += 30 + interpLines.length * 21 + 16;
    H += 15;
    H += 30 + emotionLines.length * 21 + 16;
    H += 15;
    H += 24 + 24;
    H += 15;
    H += closingLines.length * 21 + 10;
    H += pad + 10;

    const oc = document.createElement('canvas');
    oc.width = W; oc.height = H;
    const c = oc.getContext('2d');

    const bg = c.createLinearGradient(0, 0, W, H);
    bg.addColorStop(0, '#FFFCF2');
    bg.addColorStop(1, '#FFF6E6');
    c.fillStyle = bg;
    c.fillRect(0, 0, W, H);

    c.strokeStyle = '#FFD700';
    c.lineWidth = 3;
    c.strokeRect(14, 14, W - 28, H - 28);

    let y = pad;

    c.font = `bold 26px ${ff}`;
    c.fillStyle = '#FF6B6B';
    c.textAlign = 'center';
    c.fillText('ğŸ¨ ë‚™ì„œ ë¶„ì„ê°€', W / 2, y + 26);
    y += 40;

    if (isGPT) {
        c.fillStyle = '#10B981';
        drawRoundRect(c, W / 2 - 48, y, 96, 18, 9);
        c.fill();
        c.fillStyle = '#fff';
        c.font = `bold 11px ${ff}`;
        c.fillText('GPT-4o-mini', W / 2, y + 13);
        y += 22;
    }

    y += 15;

    const dX = (W - dW) / 2;
    c.save();
    c.shadowColor = 'rgba(0,0,0,0.1)';
    c.shadowBlur = 15;
    c.fillStyle = '#FFFDF7';
    c.fillRect(dX - 5, y - 5, dW + 10, dH + 10);
    c.restore();
    c.strokeStyle = '#FFE4C9';
    c.lineWidth = 2;
    c.strokeRect(dX - 2, y - 2, dW + 4, dH + 4);
    c.drawImage(canvas, dX, y, dW, dH);
    y += dH + 20;

    c.font = `italic bold 22px ${ff}`;
    c.fillStyle = '#8B4513';
    c.textAlign = 'center';
    c.fillText(title, W / 2, y + 22);
    y += 35;

    c.font = smallF;
    c.fillStyle = '#888';
    c.fillText(movementLine, W / 2, y + 13);
    y += 22;

    c.font = '22px sans-serif';
    c.fillStyle = '#333';
    c.fillText(starsText, W / 2, y + 22);
    y += 40;
    y += 15;

    c.textAlign = 'left';

    const iBoxH = 30 + interpLines.length * 21 + 8;
    c.fillStyle = 'rgba(255,255,255,0.6)';
    c.fillRect(pad, y, tw, iBoxH);
    c.fillStyle = '#FFD700';
    c.fillRect(pad, y, 4, iBoxH);
    c.font = labelF; c.fillStyle = '#D4456B';
    c.fillText('ğŸ“œ ì‘í’ˆ í•´ì„', pad + 16, y + 20);
    y += 30;
    c.font = bodyF; c.fillStyle = '#444';
    for (const ln of interpLines) {
        if (ln === '') { y += 8; continue; }
        c.fillText(ln, pad + 16, y + 15);
        y += 21;
    }
    y += 16 + 15;

    const eBoxH = 30 + emotionLines.length * 21 + 8;
    c.fillStyle = 'rgba(255,200,200,0.15)';
    c.fillRect(pad, y, tw, eBoxH);
    c.font = labelF; c.fillStyle = '#D4456B';
    c.fillText('ğŸ’­ ê°ì • ë¶„ì„', pad + 16, y + 20);
    y += 30;
    c.font = bodyF; c.fillStyle = '#444';
    for (const ln of emotionLines) {
        c.fillText(ln, pad + 16, y + 15);
        y += 21;
    }
    y += 16 + 15;

    c.font = `14px ${ff}`; c.fillStyle = '#555';
    c.fillText(priceLine, pad, y + 14); y += 24;
    c.fillText(exhibLine, pad, y + 14); y += 24;
    y += 15;

    c.font = `italic 15px ${ff}`;
    c.fillStyle = '#999';
    c.textAlign = 'center';
    for (const ln of closingLines) {
        c.fillText(ln, W / 2, y + 15);
        y += 21;
    }

    c.font = `11px ${ff}`;
    c.fillStyle = '#ddd';
    c.fillText('ë‚™ì„œ ë¶„ì„ê°€ Â· Doodle Analyzer', W / 2, H - 18);

    const a = document.createElement('a');
    const now = new Date();
    const ts = `${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}_${String(now.getHours()).padStart(2,'0')}${String(now.getMinutes()).padStart(2,'0')}`;
    a.download = `ë‚™ì„œë¶„ì„_${ts}.png`;
    a.href = oc.toDataURL('image/png');
    a.click();
}

// ============================================================
//  Email Feature
// ============================================================
function openEmailModal() {
    document.getElementById('email-input').value = '';
    document.getElementById('email-status').className = '';
    document.getElementById('email-status').style.display = 'none';
    document.getElementById('send-email-btn').disabled = false;
    document.getElementById('email-modal').classList.add('show');
    setTimeout(() => document.getElementById('email-input').focus(), 100);
}

function closeEmailModal() {
    document.getElementById('email-modal').classList.remove('show');
}

function generateResultImage() {
    const mc = document.getElementById('modal-content');
    const W = 960, pad = 40, tw = W - pad * 2;
    const ff = '"Apple SD Gothic Neo","Malgun Gothic","Noto Sans KR",sans-serif';
    const bodyF = `15px ${ff}`, smallF = `13px ${ff}`, labelF = `bold 14px ${ff}`;

    const title = mc.querySelector('.title-work')?.textContent?.trim() || 'ë¬´ì œ';
    const infos = [...mc.querySelectorAll('.info-line')];
    const movementLine = infos[0]?.textContent?.trim() || '';
    const priceLine = infos.find(el => el.textContent.includes('ê²½ë§¤ê°€'))?.textContent?.trim() || '';
    const exhibLine = infos.find(el => el.textContent.includes('ì „ì‹œ'))?.textContent?.trim() || '';
    const starsText = mc.querySelector('.stars')?.textContent?.trim() || '';
    const interpEl = mc.querySelector('.interpretation');
    const interpText = interpEl ? [...interpEl.querySelectorAll('p')].filter(p => !p.querySelector('.label')).map(p => p.textContent.trim()).join('\n\n') : '';
    const emotionEl = mc.querySelector('.emotion');
    const emotionText = emotionEl ? [...emotionEl.querySelectorAll('p')].filter(p => !p.querySelector('.label')).map(p => p.textContent.trim()).join(' ') : '';
    const closing = mc.querySelector('.closing')?.textContent?.trim() || '';
    const isGPT = !!mc.querySelector('.gpt-tag');

    const m = document.createElement('canvas').getContext('2d');
    m.font = bodyF;
    const interpLines = wrapLines(m, interpText, tw - 40);
    const emotionLines = wrapLines(m, emotionText, tw - 40);
    m.font = `italic 15px ${ff}`;
    const closingLines = wrapLines(m, closing, tw - 60);

    const dW = 840, dH = Math.round(840 * canvas.height / canvas.width);

    let H = pad;
    H += 40;
    if (isGPT) H += 22;
    H += 15 + dH + 20;
    H += 35 + 22 + 40 + 15;
    H += 30 + interpLines.length * 21 + 16 + 15;
    H += 30 + emotionLines.length * 21 + 16 + 15;
    H += 24 + 24 + 15;
    H += closingLines.length * 21 + 10;
    H += pad + 10;

    const oc = document.createElement('canvas');
    oc.width = W; oc.height = H;
    const c = oc.getContext('2d');

    const bg = c.createLinearGradient(0, 0, W, H);
    bg.addColorStop(0, '#FFFCF2');
    bg.addColorStop(1, '#FFF6E6');
    c.fillStyle = bg;
    c.fillRect(0, 0, W, H);

    c.strokeStyle = '#FFD700';
    c.lineWidth = 3;
    c.strokeRect(14, 14, W - 28, H - 28);

    let y = pad;

    c.font = `bold 26px ${ff}`;
    c.fillStyle = '#FF6B6B';
    c.textAlign = 'center';
    c.fillText('ğŸ¨ ë‚™ì„œ ë¶„ì„ê°€', W / 2, y + 26);
    y += 40;

    if (isGPT) {
        c.fillStyle = '#10B981';
        drawRoundRect(c, W / 2 - 48, y, 96, 18, 9);
        c.fill();
        c.fillStyle = '#fff';
        c.font = `bold 11px ${ff}`;
        c.fillText('GPT-4o-mini', W / 2, y + 13);
        y += 22;
    }

    y += 15;

    const dX = (W - dW) / 2;
    c.save();
    c.shadowColor = 'rgba(0,0,0,0.1)';
    c.shadowBlur = 15;
    c.fillStyle = '#FFFDF7';
    c.fillRect(dX - 5, y - 5, dW + 10, dH + 10);
    c.restore();
    c.strokeStyle = '#FFE4C9';
    c.lineWidth = 2;
    c.strokeRect(dX - 2, y - 2, dW + 4, dH + 4);
    c.drawImage(canvas, dX, y, dW, dH);
    y += dH + 20;

    c.font = `italic bold 22px ${ff}`;
    c.fillStyle = '#8B4513';
    c.textAlign = 'center';
    c.fillText(title, W / 2, y + 22);
    y += 35;

    c.font = smallF;
    c.fillStyle = '#888';
    c.fillText(movementLine, W / 2, y + 13);
    y += 22;

    c.font = '22px sans-serif';
    c.fillStyle = '#333';
    c.fillText(starsText, W / 2, y + 22);
    y += 40;
    y += 15;

    c.textAlign = 'left';

    const iBoxH = 30 + interpLines.length * 21 + 8;
    c.fillStyle = 'rgba(255,255,255,0.6)';
    c.fillRect(pad, y, tw, iBoxH);
    c.fillStyle = '#FFD700';
    c.fillRect(pad, y, 4, iBoxH);
    c.font = labelF; c.fillStyle = '#D4456B';
    c.fillText('ğŸ“œ ì‘í’ˆ í•´ì„', pad + 16, y + 20);
    y += 30;
    c.font = bodyF; c.fillStyle = '#444';
    for (const ln of interpLines) {
        if (ln === '') { y += 8; continue; }
        c.fillText(ln, pad + 16, y + 15);
        y += 21;
    }
    y += 16 + 15;

    const eBoxH = 30 + emotionLines.length * 21 + 8;
    c.fillStyle = 'rgba(255,200,200,0.15)';
    c.fillRect(pad, y, tw, eBoxH);
    c.font = labelF; c.fillStyle = '#D4456B';
    c.fillText('ğŸ’­ ê°ì • ë¶„ì„', pad + 16, y + 20);
    y += 30;
    c.font = bodyF; c.fillStyle = '#444';
    for (const ln of emotionLines) {
        c.fillText(ln, pad + 16, y + 15);
        y += 21;
    }
    y += 16 + 15;

    c.font = `14px ${ff}`; c.fillStyle = '#555';
    c.fillText(priceLine, pad, y + 14); y += 24;
    c.fillText(exhibLine, pad, y + 14); y += 24;
    y += 15;

    c.font = `italic 15px ${ff}`;
    c.fillStyle = '#999';
    c.textAlign = 'center';
    for (const ln of closingLines) {
        c.fillText(ln, W / 2, y + 15);
        y += 21;
    }

    c.font = `11px ${ff}`;
    c.fillStyle = '#ddd';
    c.fillText('ë‚™ì„œ ë¶„ì„ê°€ Â· Doodle Analyzer', W / 2, H - 18);

    return oc.toDataURL('image/png');
}

async function sendEmail() {
    const emailInput = document.getElementById('email-input');
    const status = document.getElementById('email-status');
    const sendBtn = document.getElementById('send-email-btn');
    const email = emailInput.value.trim();

    if (!email || !email.includes('@') || !email.includes('.')) {
        status.className = 'error';
        status.style.display = 'block';
        status.textContent = 'âŒ ì˜¬ë°”ë¥¸ ì´ë©”ì¼ ì£¼ì†Œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.';
        return;
    }

    sendBtn.disabled = true;
    status.className = 'sending';
    status.style.display = 'block';
    status.textContent = 'ğŸ“¨ ì´ë¯¸ì§€ë¥¼ ìƒì„±í•˜ê³  ì´ë©”ì¼ì„ ë³´ë‚´ëŠ” ì¤‘...';

    try {
        const imageData = generateResultImage();
        const bodyPayload = JSON.stringify({ email: email, image: imageData });

        if (PROXY_API_URL) {
            try {
                const response = await fetch(PROXY_API_URL + '/api/email', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: bodyPayload
                });
                const data = await response.json();
                if (response.ok && !data.error) {
                    status.className = 'success';
                    status.textContent = `âœ… ${email}ë¡œ ì „ì†¡ ì™„ë£Œ!`;
                    setTimeout(() => closeEmailModal(), 2000);
                    return;
                }
                throw new Error(data.error || 'Vercel ì´ë©”ì¼ ì „ì†¡ ì‹¤íŒ¨');
            } catch (vercelError) {
                console.log('Vercel email failed:', vercelError.message);
            }
        }

        const response = await fetch(PROXY_URL + '/email', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: bodyPayload
        });
        const data = await response.json();
        if (response.ok && !data.error) {
            status.className = 'success';
            status.textContent = `âœ… ${email}ë¡œ ì „ì†¡ ì™„ë£Œ!`;
            setTimeout(() => closeEmailModal(), 2000);
        } else {
            throw new Error(data.error || 'ì´ë©”ì¼ ì „ì†¡ ì‹¤íŒ¨');
        }
    } catch (e) {
        status.className = 'error';
        status.style.display = 'block';
        status.textContent = `âŒ ${e.message}`;
        sendBtn.disabled = false;
    }
}

document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') { closeModal(); closeEmailModal(); closeDetailModal(); }
});

// Auto-set GPT mode on load if API key is configured
if (HAS_API_KEY) {
    const btn = document.getElementById('analyze-btn');
    btn.innerHTML = 'ğŸ¤– GPT ë¶„ì„';
    btn.classList.add('gpt-mode');
}

// Load gallery on page load
loadGallery();
// Auto-refresh gallery every 30 seconds
setInterval(loadGallery, 30000);
</script>
</body>
</html>
